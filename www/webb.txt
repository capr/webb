# Webb Framework

## HowTO

### main.lua

~~~{.lua}
require'webb'
require'query'     -- if using mysql
require'sendmail'  -- if sending mail
require'session'   -- if needing session tracking and/or user accounts
require'config'    -- config.lua file, see below
require'secrets'   -- secrets.lua file, see below
pp = require'pp'   -- optional, for debugging

return function()
	touch_usr() --update usr.atime on all requests, except image requests.
	if not action(unpack(args())) then
		check_img()
	end
	check(false)
end
~~~

### config.lua

~~~{.lua}
config('basepath',  '../www')     --where www is relative to nginx wrapper script
config('lang',      'en')         --default language
config('smtp_host', '127.0.0.1')  --the ip address of the local smtp server
config('db_host',   '127.0.0.1')  --the ip address of the local mysql server
config('db_port',   3306)         --the port of the local mysql server
config('db_name',   '<db name>')  --the mysql database name
config('db_user',   'root')       --the mysql user
config('db_conn_timeout', 3)      --connection timeout in seconds
config('db_query_timeout', 30)    --query timeout in seconds


config('facebook_app_id',  '<fb app id>')         --fb app id for fb authentication
config('google_client_id', '<google client id>')  --google client id for g+ authentication
config('analytics_ua',     '<analytics UA code>') --google analytics UA code for analytics
~~~

### secrets.lua, not to be added to git

~~~{.lua}
config('pass_salt',      '<any random string>') --for encrypting passwords in the database
config('session_secret', '<any random string>') --for encrypting cookies
config('db_pass',        '<database password>') --the mysql password
~~~

###


## Server-side API

### TODO

	* markdown preprocessor
	* cascaded actions: html.m.lua, html.m.lp, etc.

### Requires

	glue cjson lfs hige lp socket

### Exports

	glue

### CONFIG

	config(name[, default_val]) -> val		get/set config value
	S(name[, default_val])						get/set internationalized string

### ENVIRONMENT

	once(f[, clear_cache[, k]])				memoize function for current request
	env([t]) -> t									per-request shared environment

### REQUEST

	headers() -> t									get all headers
	headers(name) -> s							get a specific header
	method() -> s 									get the method
	method(which) -> t|f							check the method
	post() -> t										get all POST args
	post(name) -> s								get a POST arg
	args() -> t										return path /a/b/... as {'a', 'b', ...}
	args(n) -> s									return the n'th path element
	args(name) -> s								return query arg
	args'*?' -> t									return whole query as {name -> val}
	absurl([path]) -> s							get the absolute url for a path
	domain() -> s									get website domain
	email([user]) -> s							get email address of user
	client_ip() -> s								get client's ip address
	lang() -> s										get current language based on ?lang=

### ARG PARSING

	uint_arg(s) -> n | nil						validate unsigned integer arg
	str_arg(s) -> s | nil						validate/trim non-empty string arg
	enum_arg(s, values...) -> s | nil		validate enum arg
	list_arg(s[, arg_f]) -> t					validate comma-separated list arg
	id_arg(s) -> n									decode n-s and return n
	id_arg(n, s) -> s								encode n and s as n-s

### RESPONSE

	check(ret[, err]) -> ret					exit with "404 file not found"
	allow(ret[, err]) -> ret					exit with "403 forbidden"
	check_etag(etag)								exit with "304 not modified"

### OUTPUT

	out(s)											output a string
	push_out([f])									push output function or buffer
	pop_out() -> s									pop output function and flush it
	record(f) -> s									run f and collect out() calls
	print(...)										like Lua's print but uses out()
	redirect(...)									ngx.redirect
	html(s) -> s									escape html

### JSON

	json(s) -> t									decode json
	json(t) -> s									encode json

### FILESYSTEM

	basepath(file) -> path						get filesystem path (unchecked)
	filepath(file) -> path						get filesystem path if file exists
	readfile(file) -> s							get file contents

### MUSTACHE TEMPLATES

	render_string(s[, env]) -> s				render a mustache template
	render(file[, env]) -> s					render a mustache template

### LUAPAGES TEMPLATES

	include_string(s, [env], [name], ...)	run LuaPages script
	include(file, [env], ...)					run LuaPages script

### LUA SCRIPTS

	run_string(s, [env], args...) -> ret	run Lua script
	run(file, [env], args...) -> ret			run Lua script

### HTML FILTERS

	filter_lang(s) -> s							filter <t> tags and :lang attrs
	filter_comments(s) -> s						filter <!-- --> comments

### CATLISTS

	catlist(file)									render a .cat file

### ACTIONS

	parse_path() -> name, args...				parse URI path
	action(name, args...) -> t|f				execute action (false if not found)

### QUERY

	quote(s) -> s									quote sql string
	print_queries([t|f]) -> t|f				control printing of queries
	query(s, args...) -> res					query and return result table
	query1(s, args...) -> t						query and return first row
	iquery(s, args...) -> id					query and return insert id
	changed(res) -> t|f							check if any rows were updated
	atomic(func)									execute func in transaction
	groupby(res, col) -> t						group rows by a column


### QUERY/DDL

	qsubst(typedef)								create a substitution definition
	qmacro.<name> = f(args...)					create a macro definition

	nodrop([t|f]) -> t|f							control effect
	dropfk(name)									drop foreign key
	droptable(name)								drop table
	fk(tbl, col, ...)								create a foreign key

### MAIL

	sendmail(from, rcpt, subj, msg, html)	send mail via smtp to local server

### SESSIONS

	config('pass_salt', s)						random string for salting passwords in db
	config('session_secret', s)				random string for salting session cookies

	session_uid() -> uid
	authenticate(auth) -> uid
	set_pass(pass)									set password for current user
	send_auth_token(email)

	login([auth][, switch_user]) -> uid		login
	uid() -> uid									get current user id
	uid(field) -> v								get current user id
	logout() -> uid								logout, and get an anonymous uid
	admin() -> t|f
	editmode() -> t|f

	touch_usr()										update user's atime


------------------------------------------------------------------------------

## Client-side API

### GLUE

	memoize(f) -> f									memoize function
	chain(funcs...) -> f(args...)					chain functions
	merge(dst)											$.extend() without overriding

### CONFIG

	S(name, val)
	C(name, val)

	lang()

### STRING FORMATTING

	s.format(args...) -> s
	s.trim() -> s

	firstname([fullname], [email]) ->s			get name from full name or email

### TIME FORMATTING

	rel_time(s) -> s
	timeago(timestamp) -> s
	parse_date(s) -> d
	format_time(d) -> s
	is_today(d) -> t|f
	shortdate(d, showtime) -> s
	longdate(d, showtime) -> s
	from_date(d) -> s
	update_timeago()

### PUB/SUB

	listen(topic, func)
	unlisten(topic)
	unlisten_all()
	broadcast(topic, data)

### KEYBOARD NAVIGATION

	bind_keydown(id, func)
	unbind_keydown_all()

### PERSISTENCE

	store(key, value)
	getback(key) -> value

### AJAX REQUESTS

	abort(id)
	abort_all()
	ajax(url, opt)

	get(url, success, error, opt)
	post(url, data, success, error, opt)

	load_content(dst, url, success, error, opt)

### TEMPLATING

	render(template_name, data, dst) -> s
	render_multi_column(template_name, items, col_count)
	select_map(a, selv)

### ADDRESS BAR, LINKS, SCROLLING

	hide_nav()
	check(truth)
	allow(truth)
	full_url(path, params)
	set_state_top(top)
	exec(url, params)
	action = {} // {action: handler}
	default_action = 'cat'
	parse_url(url)
	url_changed()
	setlink(a, url, params, hook)
	setlinks(dst)
	slug(id, s)
	intarg(s)
	optarg(s)
	back()
	setscroll()
	scroll_top()

### UI PATTERNS

	function follow_scroll(element_id, margin)

	function upid(e, attr)

	function notify(msg, cls)

	.back-to-top


------------------------------------------------------------------------------

# Server-side API

## Config

### `config(name[, default_val]) -> val`

Get/set config value.

### `S(name[, default_val])`

Get/set internationalized string.

# Enviornment

### `once(f[, clear_cache[, k]])`

Memoize 0-arg or 1-arg function for current request. If clear_cache is
true, then clear the cache (either for the entire function or for arg `k`).

### `env() -> t`

Per-request shared environment. Scripts run with `render()`,
`include()`, `run()` run in this environment by default.

## Sessions

### `login([auth][, switch_user]) -> uid | nil[, err]`

Login using one of the supported authentication methods:

  * `{type = 'session'}`: login using session cookie (default). if there's
  no session cookie or it's invalid, an anonymous user is created.
  * `{type = 'anonymous'}`: login using session cookie but logout and
  create an anonymous user if the logged in user is not anonymous.
  * `{type = 'pass', action = 'login', email = , pass = }`: login
  to an existing user using its email and password. returns
  `nil, 'user_pass'` if the email or password is wrong.
  * `{type = 'pass', action = 'create', email = , pass = }`: create
  a user and login to it. returns `nil, 'email_taken'` if the email is
  already taken. the admin flag is set for the first non-anonymous user
  to be created.
  * `{type = 'nopass', email = }`: login using only user
  * `{type = 'update', email = , name = ', phone = }': update the info
  of the currently logged in user. an attempt to change the email to the
  email of a different user results in `nil, 'email_taken'`.
  * `{type = 'token', token = }`: login using a temporary token that was
  generated by the remember password form. a token can be used only once.
  returns `nil, 'invalid_token'` if the token was not found or expired.
  * `{type = 'facebook', access_token = }`: login using facebook
  authentication. user's fields `email`, `facebookid`, `name`, and `gender`
  are also updated.
  * `{type = 'google', access_token = }`: login using google+
  authentication. user's fields `email`, `googleid`, `gimgurl` and `name`
  are also updated.

NOTE: Regardless of how the user is authenticated, the session cookie is
updated and it will be sent with the reply. If there was already a user
logged in before and it was a different user, the callback
`switch_user(new_uid, old_uid)` is called. If that previous user was
anonymous then that user is also deleted.

### `uid() -> uid`

Get the current user id. Same as calling `login()` without args but
caches the uid so it can be called multiple times without actually
performing the login.

### `uid(field) -> v`

Get the value of a a specific field from the user info.

### `uid'*' -> t`

Get full user info.

### `logout() -> uid`

Clears the session cookie and creates an anonymous user and returns it.

### `admin() -> t|f`

Returns true if the user has the admin flag.

### `editmode() -> t|f`

Same as `admin()`. Override to add more logic to it.

### `touch_usr()`

Update user's access time. Call it on every request as a way of tracking
user activity, eg. for knowing when to send those annoying "forgot items
in your cart" emails.


------------------------------------------------------------------------------

# Client-side API

WEBB API
------------------------------------------------------------------------------
CONFIG ENV REQUEST OUTPUT JSON MUSTACHE LUAPAGES LUA GZIP HTML CATLISTS ACTIONS
QUERY MAIL SESSION USERS

REQUIRES
	glue cjson lfs hige lp zlib resty_mysql (pp) socket
	main

CONFIG

	config(name[, default_val]) -> val		get/set config value
	S(name[, default_val])						get/set internationalized string

ENV

	once(f)											memoize function for current request
	env() -> t										per-request shared environment

REQUEST

	headers([h]) -> v | t
	GET([name]) -> v | t
	POST([name]) -> t | t
	absurl([path]) -> s							get the absolute url for a path
	domain() -> s									get website domain
	email([user]) -> s							get email address of user or 'no-reply'
	client_ip() -> s								get client's ip address
	lang() -> s										get current language based on ?lang=

	uint_arg(s) -> n | nil						validate unsigned integer arg
	str_arg(s) -> s | nil						validate/trim non-empty string arg
	enum_arg(s, values...) -> s | nil		validate enum arg
	list_arg(s[, arg_f]) -> t					validate comma-separated list arg

	check(ret[, err]) -> ret					exit with "file not found"
	allow(ret[, err]) -> ret					exit with "forbidden"

OUTPUT

	out(s)											output a string
	push_out([f])									push output function or buffer
	pop_out() -> s									pop output function and flush it
	record(f) -> s									run f and collect out() calls

	print(...)										print, setting text/plain

JSON

	json(s) -> t									decode json
	json(t) -> s									encode json

FILESYSTEM

	basepath(file) -> path						get filesystem path (unchecked)
	filepath(file) -> path						get filesystem path if file exists
	readfile(file) -> s							get file contents

MUSTACHE TEMPLATES

	render_string(s[, env]) -> s				render a mustache template
	render(file[, env]) -> s					render a mustache template

LUAPAGES TEMPLATES

	include_string(s[, env][, chunkname])	run LuaPages script
	include(file[, env])							run LuaPages script

LUA SCRIPTS

	run_string(s[, env], args...) -> ret	run Lua script
	run(file[, env], args...) -> ret			run Lua script

GZIP FILTER

	gzip_filter(f, gen_etag) -> f				run f and gzip out() calls

HTML FILTERS

	filter_lang(s) -> s							filter <t> tags and :lang attrs
	filter_comments(s) -> s						filter <!-- --> comments

CATLISTS

	catlist(file)									render a .cat file

ACTIONS

	parse_path() -> name, args...				parse URI path
	action(name, args...) -> t|f				execute action (false if not found)

QUERY

	quote(s) -> s									quote sql string
	print_queries([t|f]) -> t|f				control printing of queries
	query(s, args...) -> res					query and return result table
	query1(s, args...) -> t						query and return first row
	iquery(s, args...) -> id					query and return insert id
	changed(res) -> t|f							check if any rows were updated
	atomic(func)									execute func in transaction
	groupby(res, col) -> t						group rows by a column


QUERY/DDL

	qsubst(typedef)								create a substitution definition
	qmacro.<name> = f(args...)					create a macro definition

	nodrop([t|f]) -> t|f							control effect
	dropfk(name)									drop foreign key
	droptable(name)								drop table
	fk(tbl, col, ...)								create a foreign key

MAIL

	sendmail(from, rcpt, subj, msg, html)	send mail via smtp to local server

SESSION

	config('pass_salt', s)						random string for salting passwords in db
	config('session_secret', s)				random string for salting session cookies

	session_uid() -> uid
	authenticate(auth) -> uid
	set_pass(pass)									set password for current user
	send_auth_token(email)

	login(auth[, switch_user]) -> uid		login
	uid() -> uid									get current user id
	logout() -> uid								logout, and get an anonymous uid
	admin() -> t|f
	editmode() -> t|f

	touch_usr()										update user's atime



## Sessions

### `login([auth]) -> uid`

Login using one of the supported authentication methods:

  * `{type = 'session'}`: login using session cookie (default). if there's
  no session cookie or it's invalid, an anonymous user is created.
  * `{type = 'anonymous'}`: login using session cookie but logout and
  create an anonymous user if the logged in user is not anonymous.
  * `{type = 'pass', action = 'login', email = , pass = }`: login
  to an existing user using user and password. returns `nil, 'user_pass'`
  if the user or password is wrong.
  * `{type = 'pass', action = 'create', email = , pass = }`: create
  a user and login to it. returns `nil, 'email_taken'` if the email is
  already taken. the admin flag is set for the first non-anonymous user
  to be created and also if the current logged in user is an admin
  (i.e. first user is admin and admins create admins).
  * `{type = 'update', email = , name = ', phone = }': update the info
  of the currently logged in user.
  * `{type = 'token', token = }`: login using a temporary token that was
  generated by the remember password form. a token can be used only once.
  * `{type = 'facebook', access_token = }`: login using facebook
  authentication. user's fields `email`, `facebookid`, `name`, and `gender`
  are also updated.
  * `{type = 'google', access_token = }`: login using google+
  authentication. user's fields `email`, `googleid`, `gimgurl` and `name`
  are also updated.

NOTE: Regardless of how the user is authenticated, the session cookie is
updated and it will be sent with the reply. If there was already a user
logged in before and it was a different user, the function
`switch_user(new_uid, old_uid)` is called. If that previous user was
anonymous then that user is also deleted.

### `uid() -> uid`

Get the current user id. Same as calling `login()` without args but
caches the uid so it can be called multiple times without actually
performing the login.

### `logout() -> uid`

Clears the session cookie and creates an anonymous user and returns it.

### `admin() -> t|f`

Returns true if the user has the admin flag.

### `editmode() -> t|f`

Same as `admin()`. Override to add more logic to it.

### `touch_usr()`

Update user's access time. Call it on every request as a way of tracking
user activity, eg. for knowing when to send those annoying "forgot items
in your cart" emails.


